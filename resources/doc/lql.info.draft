#############################
###                       ###
### Lambda Query Language ###
###                       ###
#############################

#############
#
# Preface
#
#############


En math√©matique et plus encore dans de nombreux
autres domaines, il est important de bien mod√©liser
les ph√©nom√®nes et les fonctionnalit√©s dont les gens
se servent pour faire leurs m√©tiers. Cependant il
n'existe pas de langage permettant de tous mod√©liser.
Les lambdas en math√©matique permettent de mod√©liser
l'ensemble des outils et primitives math√©matiques
existants √† l'heure actuelle. De fait, les lambdas
semblent √™tre le bon candidat pour √™tre la base de
d'un langage de mod√©lisation universel.



###########################
#
# Le langage
#
###########################


Le langage LQL proposera une impl√©mentation
native des nombress, operationsarithm√©tique,
traitement bool√©ens.... Le tout sera pr√©sent
dans un fichier standart.lql qui sera √† import√©
pour tout programme voulant en profiter.

Le langage reposera sur plusieur precepte :
√- La fonction est le centre de tout
 - On pourra donner un alias √† une fonction
 - On pourra inventer ces propres keyword (il y en a pas puisque tout est fonction).
 - On devra mettre en place une m√©canique de m√©taprogrammation.

########################
#
# La fonction
#
########################

"La fonction est le centre de tout".
Cette pens√©e est au centre detout nos
concept que nous allons d√©veloppez cidesssous.

Une fonction au sens strict du terme est objet
math√©matique capable d'appliqu√© une transformation
sur un autre objet mat√hmatique pour en retourner
un tiers r√©sultant decette transformation.
L'objet d'origine n'√©tant pa intr√©sequement
chabng√© mais la traformation ayant g√©n√©r√©
nouvel objet m√™me si celui es une copie conforme
du premier.

Une fonction ne prend qu'une entr√©e etne retourne
qu'une seule sortie (apr√®s, rien n'√empeche que l'unique
sortie soit en r√©alit√© un objet composite complexe... !)


########################
#
# Les alias
#
########################

Les alias sont un moyen de donn√er u identifiant
√† une fonction. Dans la couche aliasing, il n'y
aura pas que les alias mais aussi les familles
d'alias, les templates d'alias.... On pourrait dire
qu'il s'agit la de la couche metalangage. De base
un alias est donc un simple nom r√©presentant la
composition de plusieurs fonction qui donc est
elle meme une fonction

Grace aux alias on va donc pouvoir nomm√© les
fonctions et encapsuler ces noms dans des espaces
de nom ou famille de nom afin de proposer un
classement par m√©tierde ces fonctionnalit√©s.

#########################
#
# Notation polonaise
#
#########################

Quand on lit une phrase du genre :
"Pour obtenir le BENEFICE , je do SOUSTRAIRE
les DEPENSES  et les RECETTES", on peut
traduire ca en :
BENEFICE: SOUSTRAIRE DEPENSES RECETTES

BENEFICE est ici un alias, SOUSTRAIRE
une fonction et DEPENSES et RECETTES
sont les arguments de cette fonction.
Ceci dit, nous avons dit pr√©cedemment
qu'une fonction ne devait prendre qu'un
seul argument pour n'en retourn√© qu'un
seul √©galement. Donc en r√©alit√©, d'un
point de vue fonctionnel, nous avons la
chose suivante :
BENEFICE: ((SOUSTRAIRE DEPENSES) RECETTES)

On parle donc de composition ou d'application.

On peut d√©finir soustraire par :
SOUSTRAIRE : !mn.(n PRED) m

SOUSDEPENSE: SOUSTRAIRE DEPENSES : !√EPENSES n.(n PRED) DEPENSES

SOUSDEPENSE RECETTES: !DEPENSES RECETTE.(RECETTES PRED) DEPENSES

BENEFICE : SOUSDEPENSE RECETTES

########################
#
# Metaprogrammation
#
########################

ordinal : ord0 ... ordN
name<ordinal> -> alias

template<alias n, category cat>
my_suite :
	 cat::plus
		n
		my_suite<cat::pred n, cat>


template<alias m, category cat>
my_suite<0, cat> :
	    1

equal my_suite<4, math> 10 


template<alias ... m>
my_list : standart::list<0, 1, 2>


template<
	template<alias ...> alias ... test,
	alias ... m
	>
my_generic_list : test<m...>...


#############################
#
# Category
#
#############################

category number:
	 final name<ord0>: !f!x -> x
	 final name<ordN>: !f!x -> f((name<ordN - ord1>)x)

########################
#
# R√©cursivit√©
#
########################

Laes fonctions r√©cursive d√©finisse dcas indic√©.
Pour cela on met en place la notion native d'indice.
les indices fonctionnel de d√©finir lescas d'appel
de la fonction r√©cursie :
   - 



#############################
#
# Standart.lql
#
#############################

Le fichier standart.lql aura pour objectif de proposer
une version standart des fonctions communees d√©finissant
les nombres, les booleans, les listes, map, pair...

Le mot cl√© "final" nous sera tr√®s utile dance ficher.
En effet, "final" signifie que l'√©valuation dela
lambda expression ne doit plonger dans l'√©valuation d'un
termes dit final !

Par exemple, la mod√©lisation des entirs naturel, il ne sera
pas necessaire de se lancer dans l'√©valuation meme du contenu
fonctionnel du nombre. Cela ne nous interesse pas!


#############################
#
# Les g√©n√©ratces
#
#############################

Une g√©n√©ratrice est un pan dla ma√©taprogrammation permettant
de g√©n√©r√© ensemble d'alias d'un seul coup en d√©finissant
les cas terminaux et le cas g√©n√©rateur.

Par exemple, les nombres entiers sont d√©fnis  de cette mani√®re :

number...
(
	final 0   : !fx.x
	final 1   : !fx.fx
	final n...: !fx.f(pred n f x)
)

dans l'exe√mplepr√©c√©dent nous voyonun probl√®me :
comment va faire l'interpr√©teur pour deviner quel
est la mani√®e dont vont √™treg√©n√©rles suites de
caract√®res r√©pr√©sentant lalias. C'est pourquoi
dans une g√©n√©ratriceles alias aussi ob√©issent √†
des lois de g√©n√©ration propraux identifiants d'alias.

Notons aussi que l'op√©rateur ... est symboeld'une gn√©n√©ratrice.

number...
(
	final 0 : !fx.x
	final 1 : !fx.fx
	final "[0-9]+" : !fx.f(pred alias f x )
)

OK ! mais cpar expression √r√©guli√®on determiner quel est l'alias
gn√©n√©r√©, malque cela reste une piste √† ne pas oublier !

Essayons autre chose : utilisons des expressions math√©matiques
dans les concat√©n√ations de chaine dcaract√®res :

Avant cela nous allons d√©finirles ordinaux. Les ordinaux d√©finissnt
l'ordre d'une fonction ou autrement dit, le nombre de fois qu'une fonction
s'applique en oignon sur un lambda terme.
On utilise les ordinaux de la mani√®re suivante :

an_alias : !fx.f^ord4 x

ce qui est q√©quivalen√†

an_alias : !fx.f(f(f(f(x))))

on d√finit aussi l'ordinal g√©n√©riquordn qui permet de r√epr√©senter l'ordinal
n et donc il peut √™tre vue comme le joker des ordinaux.


On peut donc redefinir les number... :

number...
(
	final 0 : !fx.x
	final 1 : !fx.fx
	final ordn : !fx.f√ß^ordn x
)

OK ! on approche, mais ce n'est pas encore fini. Nous avons encore le
pb que l'alias g√©n√©r√© eordn et pas n.
Pour cela on reprend les id√©es des expressions r√©guli√®res mais po
extraire une sous chaine d'une chaine.

dans une chaine de caract√®re ." l'o^p√©rateur{} vois ce qu'il y
a l'int√©rieur comme une iop√©ration arithm√©tique qu'il faut √©valuer
au moment de la compilation. et le mot alias  permet de faire rÈfÈrence
‡ l'alias courant. 

number...
(
	final 0 : !fx.x
	final 1 : !fx.fx
	final "[0-9]+" : !fx.f(pred "{alias - 1}" f x)
)

Dans cet exemple, le mot alias r√epr√©sente'identifiant g√©n√©r√© 
par l'expression r√©guli√®r"e [0√-". 
Donc si nous devions √©valuer l'expression 
     PLUS 3 4

Nous rechercherions si 3 peut existe parmi les alias, puis parmis les g√©n√©ratrices.
Pour cela, nous observons laquel lui correspond (la correspondance doit √™tre unique).

Une fois trouv√©, nous g√©n√©rons l'abstracn tioderri√®re l'alias. 

pUis nous ferions de m√™me avec4 et enfin nous pourrions Èvaluer PLUS 3 4

Mais gr√¢ce aux ordinaux nous pouvons offrir une dÈfinition plus performante
des nombres :

number...
{
	final "[0-9]+" : !fx.f^ord"alias" x
}


A rÈflechir: est ce que number... est nÈcÈssaire.


plus : !m n f x. m f(n f x)
plus : !m n f x. f^{ord"m"+ord"n"} x
plus 3 4 = !fx.f^ord7 x


Quand on analyse la derniere ligne, on se dit, 
qu'on aimerait retrouver l'alias 7 plutot que 
la formule compliquÈ. En bref, nous y sommes 
presque



succ : !n f x.f(n f x)

succ : !n f x.f^ord"{n}" x 

On va poser deux rËgles sur les gÈnÈratrices :
 - Les expressions rÈguliËres ne sont possible que du cotÈ de l'alias
 - Les concatÈnation de chaine ne sont possible qu'avec l'opÈrateur de composition et donc indirectement l'utilisation de {}

Dans l'expression {} seul les opÈrateurs arithmÈtiques suivant sont
autorisÈs : + - * / (division entiËre) et % (modulo)

l'opÈrateur {} dans une chaine de caractËre provoque : 
 - le remplacement de "alias" par l'alias courant de la dÈfinition
 - le remplacement d'un alias reprÈsentant un paramÍtre par sa valeur effectif

on peut donc avoir {n-1} avec n = 2 {2-1} = {1} = 1
ou bien on peut aussi utiliser la forme ordinal et avoir {ord2 - ord1} = ord1

La concatÈnation de chaine se fait simplement entre une suite de lettre et un rÈsultat de calcul traduit en chaine par "". Notons qu'on
peut aussi utiliser des caractËre dans "" sans pour autant qu'il soit dans un calcul. De fait, ce sont des bout qui seront concatÈnÈ tel
quel.


Pour l'instant nous allons garder la forme
<generatrice_name>...
(
	<generatrice_aliasing>
)

Cela permet d'isoler les gÈnÈratrices dans le code source.





