#############################
###                       ###
### Lambda Query Language ###
###                       ###
#############################

#############
#
# Preface
#
#############


En math√©matique et plus encore dans de nombreux
autres domaines, il est important de bien mod√©liser
les ph√©nom√®nes et les fonctionnalit√©s dont les gens
se servent pour faire leurs m√©tiers. Cependant il
n'existe pas de langage permettant de tous mod√©liser.
Les lambdas en math√©matique permettent de mod√©liser
l'ensemble des outils et primitives math√©matiques
existants √† l'heure actuelle. De fait, les lambdas
semblent √™tre le bon candidat pour √™tre la base de
d'un langage de mod√©lisation universel.



###########################
#
# Le langage
#
###########################


Le langage LQL proposera une impl√©mentation
native des nombress, operationsarithm√©tique,
traitement bool√©ens.... Le tout sera pr√©sent
dans un fichier standart.lql qui sera √† import√©
pour tout programme voulant en profiter.

Le langage reposera sur plusieur precepte :
√- La fonction est le centre de tout
 - On pourra donner un alias √† une fonction
 - On pourra inventer ces propres keyword (il y en a pas puisque tout est fonction).
 - On devra mettre en place une m√©canique de m√©taprogrammation.

########################
#
# La fonction
#
########################

"La fonction est le centre de tout".
Cette pens√©e est au centre detout nos
concept que nous allons d√©veloppez cidesssous.

Une fonction au sens strict du terme est objet
math√©matique capable d'appliqu√© une transformation
sur un autre objet mat√hmatique pour en retourner
un tiers r√©sultant decette transformation.
L'objet d'origine n'√©tant pa intr√©sequement
chabng√© mais la traformation ayant g√©n√©r√©
nouvel objet m√™me si celui es une copie conforme
du premier.

Une fonction ne prend qu'une entr√©e etne retourne
qu'une seule sortie (apr√®s, rien n'√empeche que l'unique
sortie soit en r√©alit√© un objet composite complexe... !)


########################
#
# Les alias
#
########################

Les alias sont un moyen de donn√er u identifiant
√† une fonction. Dans la couche aliasing, il n'y
aura pas que les alias mais aussi les familles
d'alias, les templates d'alias.... On pourrait dire
qu'il s'agit la de la couche metalangage. De base
un alias est donc un simple nom r√©presentant la
composition de plusieurs fonction qui donc est
elle meme une fonction

Grace aux alias on va donc pouvoir nomm√© les
fonctions et encapsuler ces noms dans des espaces
de nom ou famille de nom afin de proposer un
classement par m√©tierde ces fonctionnalit√©s.

#########################
#
# Notation polonaise
#
#########################

Quand on lit une phrase du genre :
"Pour obtenir le BENEFICE , je do SOUSTRAIRE
les DEPENSES  et les RECETTES", on peut
traduire ca en :
BENEFICE: SOUSTRAIRE DEPENSES RECETTES

BENEFICE est ici un alias, SOUSTRAIRE
une fonction et DEPENSES et RECETTES
sont les arguments de cette fonction.
Ceci dit, nous avons dit pr√©cedemment
qu'une fonction ne devait prendre qu'un
seul argument pour n'en retourn√© qu'un
seul √©galement. Donc en r√©alit√©, d'un
point de vue fonctionnel, nous avons la
chose suivante :
BENEFICE: ((SOUSTRAIRE DEPENSES) RECETTES)

On parle donc de composition ou d'application.

On peut d√©finir soustraire par :
SOUSTRAIRE : !mn.(n PRED) m

SOUSDEPENSE: SOUSTRAIRE DEPENSES : !√EPENSES n.(n PRED) DEPENSES

SOUSDEPENSE RECETTES: !DEPENSES RECETTE.(RECETTES PRED) DEPENSES

BENEFICE : SOUSDEPENSE RECETTES

########################
#
# Metaprogrammation
#
########################

ordinal : ord0 ... ordN
name<ordinal> -> alias

template<alias n, category cat>
my_suite :
	 cat::plus
		n
		my_suite<cat::pred n, cat>


template<alias m, category cat>
my_suite<0, cat> :
	    1

equal my_suite<4, math> 10 


template<alias ... m>
my_list : standart::list<0, 1, 2>


template<
	template<alias ...> alias ... test,
	alias ... m
	>
my_generic_list : test<m...>...


#############################
#
# Category
#
#############################

category number:
	 final name<ord0>: !f!x -> x
	 final name<ordN>: !f!x -> f((name<ordN - ord1>)x)
